# 性能优化

- 面向前端人员
- 主流的，面向chrome、90%

## 浏览器的内核(渲染引擎)

- 在浏览器中有一个最重要的模块，它主要的作用把一切请求回来的资源变成可视化的图像，这个模块就是浏览器内核，通常也叫渲染引擎

## 常见的内核总结

- IE--------------Trident
- Safari----------Webkit(v8引擎)
- Chrome----------Webkit的分支引擎(Blink)
- Opera-----------Blink
- Firefox---------Gecko

## 进程和线程

- CPU
- 多核多线程
- 调度算法
  - 先来先服务
  - 优先级
  - 时间片轮转

## 现代浏览器：多进程多线程模型

- 浏览器的进程
  - Browser进程
    - 浏览器的主进程，负责浏览器界面的显示，和各个页面的管理，浏览器中所有其他类型进程的祖先，负责其他进程的创建和销毁，它有且只有一个
  - Renderer进程
    - 网页渲染进程，负责页面的渲染，可以有多个，渲染进程数量不一定等于打开网页的个数
  - 各种插件进程
  - GPU进程
    - 移动设备的浏览器不太一样
    - Android不支持插件，所以没有插件进程
    - GPU演化成了Browser进程的一个线程
    - Renderer进程演化成了操作系统的一个服务进程，它仍然是独立的
  - 每个进程又有多个线程
    - 为了不让Browser进程的UI线程被其他耗时的操作(大文件的加载，本地文件读写)所阻塞，我们把这些操作放到分线程中去处理
    - 在Renderer进程中，为了不让其他操作阻止渲染线程的高速执行，我们通常会将渲染进程管线化，利用计算机的多核优势，让渲染的不同阶段在不同的线程中执行

## 浏览器渲染引擎

### 主要模块

- HTML解析器
- CSS解析器
- javascript引擎
- 布局layout模块
- 绘图模块

### 大致的渲染过程

1. HTML解析器解析html
2. style/link通过css标记，构建css样式树
3. script通过js引擎处理script标记
4. 将DOM树与CSS合并一个渲染树
5. 根据渲染树来渲染，计算每个节点的几何信息(依赖GPU)
6. 绘制到屏幕上

## 浏览器的基本渲染过程

### 同步/异步

- 同步：阻塞
- 异步：非阻塞

### css解析

- style标签中的css样式由HTML解析器parse
- style标签写的内部样式是异步解析的(容易产生闪屏现象，结构先进入页面而样式不断变化)
- 浏览器加载资源也是异步的

## 阻塞渲染

### 关于CSS阻塞

- 声明：只有link引入的外部CSS才能产生阻塞
- style标签中的样式：
  - 由html解析器进行解析
  - 不阻塞浏览器的渲染(可能会产生闪屏现象)
  - 不阻塞DOM解析
- link引入的外部css样式(推荐使用的方式)
  - 由CSS解析器进行解析
  - 阻塞浏览器渲染(可以利用这种阻塞避免闪屏现象)
  - 阻塞其后面的js语句的执行
  - 不阻塞DOM的解析(绝大多数浏览器的工作方式)
- 优化核心理念
  - 使用CDN节点进行外部资源加速
  - 对CSS进行压缩(利用打包工具，比如webpack,gulp等)
  - 减少http请求数，将多个CSS文件合并
  - 优化样式表的代码

## 关于js的阻塞

- 阻塞后续DOM解析
  - 浏览器不知道后续脚本的内容，如果先去解析下面的DOM，而随后的js删除了后面的dom，那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析DOM
- 阻塞页面的渲染
  - js可以操作样式(闪屏)
- 阻塞后续js语句的执行
  - 维护依赖关系，例如：必须先引入jQuery再引入bootstrap

## 备注

- css的解析和js的执行是互斥的，css解析的时候js停止执行，js执行的时候css停止解析
- 无论是js阻塞还是css阻塞，都不会阻塞浏览器加载外部资源(图片，视频，样式，脚本)，浏览器始终处于一种：先把请求发出去的工作模式，只要是涉及到网络请求的内容，无论是图片，视频，音频等，都会先发送请求去获取资源，至于资源本地什么时候用，由浏览器自己协调。效率高
- webkit和firefox都进行了预解析(不是js预解析)这项优化，在执行js脚本时，浏览器的其他线程会预解析文档的其余部分，找出并加载需要通过网络加载的其他资源，通过这种方式，资源可以在并行链接上加载，从而提高总体速度，预解析不会修改DOM树

## 上面介绍的完成的渲染过程，但现代网页很多都是动态的，这意味着在渲染完成之后，由于网页的动画或者用户的交互，浏览器其实一直在不停地重复执行渲染过程。(重绘重排)

### layout排列(摆放位置)(首次排列-重新排列-重排)

### paint绘制(绘制颜色)(首次绘制-重新绘制-重绘)

### 图层

#### 浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多点。

##### 在渲染DOM的时候，浏览器所做的工作实际上是：

1. 获取DOM后分割为多个图层
2. 对每个图层的节点计算样式结果（Recalculate style--样式重计算）
3. 为每个节点生成图形和位置（Layout--布局，重排,回流）
4. 将每个节点绘制填充到图层位图中（Paint--重绘）
5. 图层作为纹理上传至GPU
6. 组合多个图层到页面上生成最终屏幕图像	（Composite Layers--图层重组）

### 图层创建的条件

#### Chrome浏览器满足以下任意情况就会创建图层

1. 拥有具有3D变换的CSS属性
2. 使用加速视频解码的```<video>```节点
3. ```<canvas>```节点
4. CSS3动画的节点
5. 拥有CSS加速属性的元素(will-change)

### 重绘(Repaint)

1. 重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据素新属性重新绘制，
2. 使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。
3. 需要注意的是：重绘重排都是以图层为单位，如果图层中某个元素需要重绘，那么整个图层都需要重绘。
4. 所以为了提高性能，我们应该让这些“变化的东西”拥有一个自己一个图层，
5. 不过好在绝大多数的浏览器自己会为CSS3动画的节点自动创建图层。

### 重排(Reflow 又称：回流)

1. 渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排
2. "重绘"不一定需要"重排"，比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。
3. "重排"大多数情况下会导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。

### 触发重绘的属性(改变外观)

color | background | outline-color
----- | ---------- | ------------
border-style | background-image | outline
border-radius | background-position | outline-style
visibility | background-repeat | outline-width
text-decoration | background-size | box-shadow

### 触发重排(回流)的属性(改变位置)

width | top | text-align
----- | --- | ----------
height | bottom | overflow-y
padding | left | font-weight
margin | right | overflow
display | position | font-family
border-width | float | line-height
border | clear | vertival-align
min-height | white-space

### 常见的触发重排的操作

1. Reflow(重排) 的成本比 Repaint(重绘) 的成本高很多很多。
2. 一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow。
3. 在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是非常痛苦耗电的。
4. 所以，下面这些动作有很大可能会是成本比较高的。
   1. 当你增加、删除、修改 DOM 结点时，会导致 Reflow , Repaint。
   2. 当你移动 DOM 的位置
   3. 当你修改 CSS 样式的时候。
   4. 当你 Resize 窗口的时候（移动端没有这个问题，因为移动端的缩放没有影响布局视口)
   5. 当你修改网页的默认字体时。
   6. 【获取某些属性时(width,height...)！！！！！】
   7. 注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。

### 优化方案（重绘重排）

#### 我们已知：浏览器渲染页面时经历了如下“细致”的环节

1. 计算需要被加载到节点上的样式结果（Recalculate style--样式重计算）
2. 为每个节点生成图形和位置（Layout--重排或回流）
3. 将每个节点填充到图层中（Paint--重绘）
4. 组合图层到页面上（Composite Layers--图层重组）
5. 如果我们需要提升性能，需要做的就是减少浏览器在运行时所需要做的工作，即：尽量减少1234步。

#### 【具体优化方案如下】

- 元素位置移动变换时尽量使用CSS3的transform来代替对top left等的操作变换（transform）和透明度（opacity）的改变仅仅影响图层的组合
- 【使用opacity来代替visibility】
  - 使用visibility不触发重排，但是依然重绘。
  - 直接使用opacity即触发重绘，又触发重排（GPU底层设计如此！）。
  - opacity配合图层使用，即不触发重绘也不触发重排。
  - 原因：
    - 透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。
    - 不过这个前提是这个被修改opacity本身必须是一个图层。
- 【不要使用table布局】
- 将【多次改变样式属性的操作合并成一次】操作
  - 不要一条一条地修改DOM的样式，预先定义好class，然后修改DOM的className
- 【将DOM离线后再修改】
  - 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。
  - 如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。
- 【利用文档碎片】(documentFragment)------vue使用了该种方式提升性能。
- 【不要把获取某些DOM节点的属性值放在一个循环里当成循环的变量】
  - 当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：
    - offsetTop, offsetLeft, offsetWidth, offsetHeight
    - scrollTop/Left/Width/Height
    - clientTop/Left/Width/Height
    - width,height
        当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要刷新内部队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。
- 动画实现过程中，启用GPU硬件加速:transform: tranlateZ(0)
- 为动画元素新建图层,提高动画元素的z-index
- 编写动画时，尽量使用如下的API

### requestAnimationFrame----请求动画帧

1. window.requestAnimationFrame() 

- 说明：该方法会告诉浏览器在下一次重绘重排之前调用你所指定的函数
- 参数：该方法使用一个回调函数作为参数，这个回调函数会在浏览器下一次重绘之前调用。
- 回调函数会被自动传入一个参数，DOMHighResTimeStamp，标识requestAnimationFrame()开始触发回调函数的当前时间
- 返回值：
  - 一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。
  - 备注：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()
2.window.cancelAnimationFrame(requestID)
- 取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。
- requestID是先前调用window.requestAnimationFrame()方法时返回的值，它是一个时间标识，用法与定时器的id类似。

### CDN

1. 网站通常将其所有的服务器都放在同一个地方，当用户群增加时，公司就必须在多个地理位置不同的服务器上部署内容
2. 为了缩短http请求的时间，我们应该把大量的静态资源放置的离用户近一点。
3. 内容发布网络CDN（Content  Delivery Networks）

- CDN是一组分布在多个不同地理位置的web服务器，用于更加有效的向用户发布内容
- 基本思路：
  - 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。
  - 通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，
  - CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息
  - 将用户的请求重新导向离用户最近的服务节点上。
- 基础架构：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成
  - 用户输入的url，会经过DNS解析“翻译”成对应的ip地址，从而找到CDN专用的服务器。
  - CDN“拿到”用户的IP地址，随后和区域负载均衡设备配合，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
  - 上述步骤中的“选择”依据
    - 选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；
    - 根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；
    - 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。

## 函数防抖

- 概念：等待要执行的动作，若在等待的这段时间内，再次触发了，则取消之前开启的动作，重新计时
- 举例：电脑无操作1分钟内没操作进入休眠，当40s鼠标动了，重新计时
- 实现：定时器
- 应用：搜索时等用户完整输入内容后再发送查询请求